import java.io.{BufferedWriter, File, FileOutputStream, OutputStreamWriter}
import java.nio.charset.StandardCharsets.UTF_8

import scala.annotation.tailrec
import scala.language._

/** Renders the autogenerated Scala sources for a given sequence of [[TemplateGroup]] under a given base directory. */
object TemplateRenderer {
  val TemplateBasePackage = "consulting.deja.cv.template"
  val TemplateImports:Seq[String] = Seq("consulting.deja.cv.io.{HTMLAppend, HTMLAppendable}", s"$TemplateBasePackage.Phrase._")

  def apply(groups:Seq[TemplateGroup], baseDirectory:File):Seq[File] = groups map {renderGroupFile(_, baseDirectory)}

  private def renderGroupFile(group:TemplateGroup, baseDirectory:File):File = {
    val targetFile = targetFileFor(group, baseDirectory)
    (targetFile getParentFile) mkdirs()
    val outputStream = new FileOutputStream(targetFile)
    try {
      val writer = new BufferedWriter(new OutputStreamWriter(outputStream, UTF_8))
      renderGroup(group, writer)
      writer flush()
    } finally {outputStream close()}
    targetFile
  }

  private def renderGroup(group:TemplateGroup, out:Appendable) {
    val pkg = templatePackage(group)
    if(pkg nonEmpty) out append s"package ${templatePackage(group)}\n\n"
    TemplateImports foreach {imp => out append s"import $imp\n"}
    out append '\n'
    out append s"object ${templateObjectName(group)} {\n"
    ((group templates) values) foreach {template => renderTemplate(template, out); out append '\n'}
    out append "}\n"
  }

  private def renderTemplate(template:Template, out:Appendable) {
    out append s"  def ${template name}[A<:HTMLAppend[A]](${renderTemplateParameters(template params)}append:A):A = {\n"
    out append "    var a:A = append\n"
    (template instructions) foreach {instruction => out append s"    $instruction\n"}
    out append "    a\n"
    out append "  }\n"

    if(isAppendableTemplate(template)) {
      out append '\n'
      renderAppendableTemplate(template, out)
    }
    if(isCaseClassTemplate(template)) {
      out append '\n'
      renderCaseClassTemplate(template, out)
    }
  }

  @tailrec private def renderTemplateParameters(params:Seq[String], soFar:String=""):String = params match {
    case Seq() => soFar
    case Seq(first, rest@_*) => renderTemplateParameters(rest, soFar + s"$first:HTMLAppendable, ")
  }

  private def renderAppendableTemplate(template:Template, out:Appendable) {
    out append s"  object ${(template name) capitalize} extends HTMLAppendable {\n"
    out append s"    def apply[A<:HTMLAppend[A]](append:A):A = ${template name}(append)\n"
    out append "  }\n"
  }
  private def renderCaseClassTemplate(template:Template, out:Appendable) {
    out append s"  final case class ${(template name) capitalize}(${(template params) map {_ + ":HTMLAppendable"} mkString ", "}) extends HTMLAppendable {\n"
    out append s"    def apply[A<:HTMLAppend[A]](append:A):A = ${template name}(${(template params) mkString ", "}, append)\n"
    out append "  }\n"
  }

  private def targetFileFor(group:TemplateGroup, baseDirectory:File):File = new File(baseDirectory, s"${TemplateBasePackage replaceAllLiterally (".", "/")}/${group name}.scala")
  private def templateObjectName(group:TemplateGroup):String = (group name) replaceAll ("""^.*/""", "")
  private def templatePackage(group:TemplateGroup):String = if((group name) contains '/') s"$TemplateBasePackage.${(group name) replaceAll ("""/([^/]*)$""", "") replaceAllLiterally ("/", ".")}" else TemplateBasePackage

  private def canBeCapitalized(str:String):Boolean = (str capitalize) != str
  private def isAppendableTemplate(template:Template):Boolean = ((template params) isEmpty) && canBeCapitalized(template name)
  private def isCaseClassTemplate(template:Template):Boolean = ((template params) nonEmpty) && canBeCapitalized(template name)
}
